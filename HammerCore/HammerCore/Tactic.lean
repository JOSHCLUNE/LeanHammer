import HammerCore.DuperCore
import HammerCore.Options

open Lean Meta Parser Elab Tactic Auto Duper Syntax

namespace HammerCore

/-- Given a Syntax.TSepArray of facts provided by the user (which may include `*` to indicate that hammer should read in the
    full local context) `removeHammerStar` returns the Syntax.TSepArray with `*` removed and a boolean that indicates whether `*`
    was included in the original input. -/
def removeHammerStar (facts : Syntax.TSepArray [`HammerCore.hammerStar, `term] ",") : Bool × Syntax.TSepArray `term "," := Id.run do
  let factsArr := facts.elemsAndSeps -- factsArr contains both the elements of facts and separators, ordered like `#[e1, s1, e2, s2, e3]`
  let mut newFactsArr : Array Syntax := #[]
  let mut removedHammerStar := false
  let mut needToRemoveSeparator := false -- If `*` is removed, its comma also needs to be removed to preserve the elemsAndSeps ordering
  for fact in factsArr do
    match fact with
    | `(hammerStar| *) =>
      removedHammerStar := true
      needToRemoveSeparator := true
    | _ =>
      if needToRemoveSeparator then needToRemoveSeparator := false -- Don't push current separator onto newFactsArr
      else newFactsArr := newFactsArr.push fact
  if removedHammerStar && needToRemoveSeparator then -- This can occur if `*` was the last or only element of facts
    return (removedHammerStar, {elemsAndSeps := newFactsArr.pop}) -- Remove the last extra separator in newFactsArr, if it exists
  else
    return (removedHammerStar, {elemsAndSeps := newFactsArr})

@[rebind Auto.Native.solverFunc]
def duperNativeSolverFunc (lemmas : Array Lemma) (_inhLemmas : Array Lemma) : MetaM Expr := do
  let (formulas, extraFormulas) ← autoLemmasToFormulas lemmas
  let formulas := formulas.map (fun f => (f.1, f.2.1, f.2.2.1, f.2.2.2, none))
  let extraFormulas := extraFormulas.map (fun f => (f.1, f.2.1, f.2.2.1, f.2.2.2, none))
  trace[hammer.debug] "Formulas passed to Duper after filtering: {formulas.map (fun x => x.1)}"
  trace[hammer.debug] "Extra formulas passed to Duper after filtering: {extraFormulas.map (fun x => x.1)}"
  Duper.runDuperPortfolioMode formulas extraFormulas .none
    { portfolioMode := true,
      portfolioInstance := none,
      inhabitationReasoning := none,
      preprocessing := none,
      includeExpensiveRules := none,
      selFunction := none
    }
    .none

def throwSimpPreprocessingError (e : Exception) : TacticM α :=
  throwError "hammer encountered an error during simp preprocessing. Try calling hammer with the simpTarget option set to no_target. Error: {e.toMessageData}"

def throwTranslationError (e : Exception) : TacticM α :=
  throwError "hammer failed to preprocess facts for translation. Error: {e.toMessageData}"

def throwExternalSolverError (e : Exception) : TacticM α :=
  throwError "hammer successfully translated the problem to TPTP, but the external prover was unable to solve it. Error: {e.toMessageData}"

def throwDuperError (e : Exception) : TacticM α :=
  throwError "hammer successfully translated the problem to TPTP and obtained an unsat core from an external prover, but was unable to reconstruct the proof. Error: {e.toMessageData}"

def throwProofFitError (e : Exception) : TacticM α :=
  throwError "hammer successfully translated the problem and reconstructed an external prover's proof, but encountered an issue in applying said proof. Error: {e.toMessageData}"

/-- A function to determine whether an error thrown by `hammer` was generated by `throwSimpPreprocessingError` -/
def errorIsSimpPreprocessingError (e : Exception) : IO Bool := do
  let eStr ← e.toMessageData.toString
  return "hammer encountered an error during simp preprocessing. Try calling hammer with the simpTarget option set to no_target.".isPrefixOf eStr

/-- A function to determine whether an error thrown by `hammer` was generated by `throwTranslationError` -/
def errorIsTranslationError (e : Exception) : IO Bool := do
  let eStr ← e.toMessageData.toString
  return "hammer failed to preprocess facts for translation.".isPrefixOf eStr

/-- A function to determine whether an error thrown by `hammer` was generated by `throwExternalSolverError` -/
def errorIsExternalSolverError (e : Exception) : IO Bool := do
  let eStr ← e.toMessageData.toString
  return "hammer successfully translated the problem to TPTP, but the external prover was unable to solve it.".isPrefixOf eStr

/-- A function to determine whether an error thrown by `hammer` was generated by `throwDuperError` -/
def errorIsDuperSolverError (e : Exception) : IO Bool := do
  let eStr ← e.toMessageData.toString
  return "hammer successfully translated the problem to TPTP and obtained an unsat core from an external prover, but was unable to reconstruct the proof.".isPrefixOf eStr

/-- A function to determine whether an error thrown by `hammer` was generated by `throwProofFitError` -/
def errorIsProofFitError (e : Exception) : IO Bool := do
  let eStr ← e.toMessageData.toString
  return "hammer successfully translated the problem and reconstructed an external prover's proof, but encountered an issue in applying said proof.".isPrefixOf eStr

def runHammerCore (stxRef : Syntax) (simpLemmas : Syntax.TSepArray [`Lean.Parser.Tactic.simpErase, `Lean.Parser.Tactic.simpLemma] ",")
  (premises : TSepArray `term ",") (includeLCtx : Bool) (configOptions : ConfigurationOptions) : TacticM Unit := withMainContext do
  Core.checkSystem s!"{decl_name%}"
  let preprocessingSuggestion ←
    tryCatchRuntimeEx (do
      match configOptions.preprocessing with
      | Preprocessing.no_preprocessing => pure #[] -- No preprocessing
      | Preprocessing.aesop => pure #[] -- Aesop's integration comes prior to calling `hammerCore`, so no preprocessing within `hammerCore` is needed
      | Preprocessing.simp_target =>
        let goalsBeforeSimpCall ← getGoals
        evalTactic (← `(tactic| simp [$simpLemmas,*]))
        let goalsAfterSimpCall ← getGoals
        if goalsBeforeSimpCall != goalsAfterSimpCall then -- Only add `simp` call to suggestion if it affected the goal state
          pure #[(← `(tactic| simp [$simpLemmas,*]))]
        else
          pure #[]
      | Preprocessing.simp_all =>
        let goalsBeforeSimpCall ← getGoals
        evalTactic (← `(tactic| simp_all [$simpLemmas,*]))
        let goalsAfterSimpCall ← getGoals
        if goalsBeforeSimpCall != goalsAfterSimpCall then -- Only add `simp_all` call to suggestion if it affected the goal state
          pure #[(← `(tactic| simp_all [$simpLemmas,*]))]
        else
          pure #[]
      )
      (fun e => do
        let eStr ← e.toMessageData.toString
        if eStr == "simp made no progress" || eStr == "simp_all made no progress" then pure #[]
        else throwSimpPreprocessingError e
      )

  if (← getUnsolvedGoals).isEmpty then
    let tacticSeq ← `(tacticSeq| $preprocessingSuggestion*)
    addTryThisTacticSeqSuggestion stxRef tacticSeq (← getRef)
    return -- The preprocessing call is sufficient to close all goals, so no more work needs to be done

  let lctxBeforeIntros ← getLCtx
  let originalMainGoal ← getMainGoal
  let goalType ← originalMainGoal.getType
  let goalType ← instantiateMVars goalType
  -- If `goalType` has the form `∀ x1 : t1, … ∀ xn : tn, b`, first apply `intros` to put `x1 … xn` in the local context
  let numBinders := getIntrosSize goalType
  let mut introNCoreNames : Array Name := #[]
  let mut numGoalHyps := 0
  /- Assuming `goal` has the form `∀ x1 : t1, ∀ x2 : t2, … ∀ xn : tn, b`, `goalPropHyps` is
     an array of size `n` where the mth element in `goalPropHyps` indicates whether the mth forall
     binder has a `Prop` type. This is used to help create `introNCoreNames` which should use existing
     binder names for nonProp arguments and newly created names (based on `goalHypPrefix`) for Prop arguments -/
  let goalPropHyps ← forallTelescope goalType fun xs _ => do xs.mapM (fun x => do pure (← inferType (← inferType x)).isProp)
  for b in goalPropHyps do
    if b then
      introNCoreNames := introNCoreNames.push (.str .anonymous (configOptions.goalHypPrefix ++ numGoalHyps.repr))
      numGoalHyps := numGoalHyps + 1
    else -- If fvarId corresponds to a non-sort type, then introduce it using the userName
      introNCoreNames := introNCoreNames.push `_ -- `introNCore` will overwrite this with the existing binder name
  let (goalBinders, newGoal) ← introNCore originalMainGoal numBinders introNCoreNames.toList true true
  let [nngoal] ← newGoal.apply (.const ``Classical.byContradiction [])
    | throwError "evalHammer :: Unexpected result after applying Classical.byContradiction"
  let (_, absurd) ← MVarId.intro nngoal (.str .anonymous configOptions.negGoalLemmaName)
  replaceMainGoal [absurd]
  withMainContext do
    let lctxAfterIntros ← getLCtx
    let goalDecls := getGoalDecls lctxBeforeIntros lctxAfterIntros
    -- **NOTE** We collect `formulas` using `Duper.collectAssumptions` rather than `Auto.collectAllLemmas` because `Auto.collectAllLemmas`
    -- does not currently support a mode where unusable facts are ignored.
    let formulas ← withDuperOptions $ collectAssumptions premises includeLCtx goalDecls
    withSolverOptions configOptions do
      let lemmas ← formulasToAutoLemmas formulas (includeInSetOfSupport := true)
      -- Calling `Auto.unfoldConstAndPreprocessLemma` is an essential step for the monomorphization procedure
      let lemmas ←
        tryCatchRuntimeEx
          (lemmas.mapM (m:=MetaM) (Auto.unfoldConstAndPreprocessLemma #[]))
          throwTranslationError
      let inhFacts ←
        tryCatchRuntimeEx
          Auto.Inhabitation.getInhFactsFromLCtx
          throwTranslationError
      let solverHints ←
        tryCatchRuntimeEx (do
          trace[hammer.debug] "Lemmas passed to runAutoGetHints {lemmas}"
          trace[hammer.debug] "inhFacts passed to runAutoGetHints {inhFacts}"
          runAutoGetHints lemmas inhFacts
          )
          (fun e => do
            if (← e.toMessageData.toString) ==  "runAutoGetHints :: External TPTP solver unable to solve the goal" then
              throwExternalSolverError e
            else
              throwTranslationError e
          )
      match configOptions.solver with
      | Solver.zipperposition =>
        let mut tacticsArr := preprocessingSuggestion -- The array of tactics that will be suggested to the user
        let unsatCoreDerivLeafStrings := solverHints.1
        trace[hammer.debug] "unsatCoreDerivLeafStrings: {unsatCoreDerivLeafStrings}"
        let duperConfigOptions :=
          { portfolioMode := true, portfolioInstance := none, inhabitationReasoning := none, includeExpensiveRules := none,
            preprocessing := some PreprocessingOption.FullPreprocessing, selFunction := none }
        let (coreLctxLemmas, coreUserInputFacts, duperProof) ←
          tryCatchRuntimeEx
            (getDuperCoreLemmas unsatCoreDerivLeafStrings premises goalDecls includeLCtx duperConfigOptions)
            throwDuperError
        -- **TODO** `intros ...; apply Classical.byContradiction` is unecessary if everything in the goal will be sent to Duper
        -- Build the `intros ...` tactic with appropriate names
        let mut introsNames := #[] -- Can't just use `introNCoreNames` because `introNCoreNames` uses `_ as a placeholder
        let mut numGoalHyps := 0
        for fvarId in goalBinders do
          let some localDecl := lctxAfterIntros.fvarIdToDecl.find? fvarId
            | throwProofFitError $ ← throwError "Unable to find fvarId {Expr.fvar fvarId} in local context (after intros)"
          let ty := localDecl.type
          if (← inferType ty).isProp then
            introsNames := introsNames.push (.str .anonymous (configOptions.goalHypPrefix ++ numGoalHyps.repr))
            numGoalHyps := numGoalHyps + 1
          else -- If fvarId corresponds to a non-sort type, then introduce it using the userName
            introsNames := introsNames.push $ Name.eraseMacroScopes localDecl.userName
        let ids : TSyntaxArray [`ident, `Lean.Parser.Term.hole] := introsNames.map (fun n => mkIdent n)
        if ids.size > 0 then
          tacticsArr := tacticsArr.push $ ← `(tactic| intros $ids*)
        -- Add `apply Classical.byContradiction` so that the unsat core can determine whether the target needs to be included in the call
        let byContradictionConst : TSyntax `term ← PrettyPrinter.delab $ mkConst ``Classical.byContradiction
        tacticsArr := tacticsArr.push $ ← `(tactic| apply $byContradictionConst)
        -- Introduce the negated hypothesis (again, so that the unsat core can determine whether the target needs to be included in the call)
        tacticsArr := tacticsArr.push $ ← `(tactic| intro $(mkIdent (.str .anonymous configOptions.negGoalLemmaName)):term)
        -- Build a Duper call using each coreLctxLemma and each coreUserInputFact
        let coreLctxLemmaIds ← coreLctxLemmas.mapM
          (fun lemFVarId => withOptions ppOptionsSetting $ PrettyPrinter.delab (.fvar lemFVarId))
        let coreUserInputFacts := coreUserInputFacts.filter (fun x => !coreLctxLemmaIds.contains x)
        tacticsArr := tacticsArr.push $ ← `(tactic| duper [$(coreLctxLemmaIds ++ coreUserInputFacts),*] {preprocessing := full})
        -- Add tactic sequence suggestion
        let tacticSeq ← `(tacticSeq| $tacticsArr*)
        -- **TODO** Add a warning if anything gets inadvertently shadowed (e.g. by `negGoal` or an introduced goal hypothesis)
        addTryThisTacticSeqSuggestion stxRef tacticSeq (← getRef)
        tryCatchRuntimeEx
          (absurd.assign duperProof)
          throwProofFitError
      | Solver.cvc5 => throwError "evalHammer :: cvc5 support not yet implemented"

@[tactic hammerCore]
def evalHammerCore : Tactic
| `(tactic| hammerCore%$stxRef [$simpLemmas,*] [$facts,*] {$configOptions,*}) => do
  let configOptions ← parseConfigOptions configOptions
  let (includeLCtx, facts) := removeHammerStar facts
  runHammerCore stxRef simpLemmas facts includeLCtx configOptions
| _ => throwUnsupportedSyntax

end HammerCore
